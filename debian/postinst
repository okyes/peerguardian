#!/bin/sh
# postinst script for blockcontrol
# see: dh_installdeb(1)

# Copyright (C) 2008 - 2009 jre <jre-phoenix@users.sourceforge.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

set -e

# summary of how this script can be called:
#	* <postinst> `configure' <most-recently-configured-version>
#	* <old-postinst> `abort-upgrade' <new version>
#	* <conflictor's-postinst> `abort-remove' `in-favour' <package>
#	  <new-version>
#	* <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#	  <failed-install-package> <version> `removing'
#	  <conflicting-package> <version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

# Note: Some of the following code is normally placed in debian/config and some
# would need to be present in both files.
# TODO: Bring it back there, but make sure that
# - purge cleans debconf db
# - configuration works (http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=352697)

# Source debconf library.
. /usr/share/debconf/confmodule

db_version 2.0 || ( echo $? ; true )

# This (deb)conf script is capable of backing up
db_capb backup || ( echo $? ; true )

case "$1" in
	configure|reconfigure)
		true	# continue below
		;;
	abort-upgrade|abort-remove|abort-deconfigure)
		exit 0
		;;
	*)
		echo "postinst called with unknown argument \"$1\"" >&2
		exit 1
		;;
esac

################################################################################
# The following code is common between blockcontrol, cron.daily, init and
# debian/postinst.

# if-up is similar, but exits successfully if CONTROL_MAIN is not there, yet.
# This can happen in early boot stages before local file systems are mounted.

# It sets the variables and loads functions

# CONTROL_MAIN has to be set correctly in all just mentioned files.
CONTROL_MAIN="/usr/lib/blockcontrol/blockcontrol.main"

# Configure blockcontrol and load functions.
if [ -f "$CONTROL_MAIN" ] ; then
	. $CONTROL_MAIN || { echo "$0 Error: Failed to source $CONTROL_MAIN although this file exists."; exit 1; }
else
	echo "$0 Error 7: Missing file $CONTROL_MAIN."
	exit 7
fi

# End of the common code between blockcontrol, cron.daily, if-up, init,
# and debian/postinst.
################################################################################


VARIABLES="
	BLOCKLIST_FORMAT
	LOG_TIMESTAMP
	LOG_SYSLOG
	LOG_IPTABLES
	VERBOSITY
	INIT
	CRON
	NFQUEUE_NUMBER
	IPTABLES_SETTINGS
	IPTABLES_ACTIVATION
	REJECT
	REJECT_IN
	REJECT_OUT
	REJECT_FW
	ACCEPT
	WHITE_LOCAL
	WHITE_TCP_OUT
	WHITE_UDP_OUT
	WHITE_TCP_IN
	WHITE_UDP_IN
	WHITE_TCP_FORWARD
	WHITE_UDP_FORWARD
	IP_REMOVE"

# Known lists in .dat format.
LISTS_DAT="
	tbg.iblocklist.com/Lists/ipfilter.dat.gz"

LISTS_P2B=""

# Known lists in .p2p format.
# Make sure LIST_NAME is also in debian/templates and LIST_NAME2LIST_URL
LISTS_P2P="
	Bluetack_level1
	Bluetack_level2
	Bluetack_level3
	Bluetack_edu
	Bluetack_ads
	Bluetack_bogon
	Bluetack_spyware
	Bluetack_spider
	Bluetack_Microsoft
	Bluetack_proxy
	Bluetack_hijacked
	Bluetack_badpeers
	Bluetack_rangetest
	Bluetack_dshield
	TBG_Primary_Threats
	TBG_General_Corporate_Ranges
	TBG_Business_ISPs
	TBG_Educational_Institutions
	TBG_Search_Engines
	TBG_Hijacked
	TBG_Bogon"

# Rename lists as bluetack did it:
if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?www.bluetack.co.uk/config/templist" $BLOCKLISTS_LIST ; then
	echo -n "Renaming list templist to badpeers as bluetack.co.uk did it..."
	sed -i -r "s|www.bluetack.co.uk/config/templist|www.bluetack.co.uk/config/badpeers|" $BLOCKLISTS_LIST
	echo "done."
fi

# Transition from moblock-control 1.2 to blockcontrol 1.3:
# Load configuration from old moblock-control package (overwrites current configuration)
[ ! -f /etc/moblock/moblock.conf ] || { \
	echo -n "Loading and backuping /etc/moblock/moblock.conf"
	. /etc/moblock/moblock.conf && \
	rm /etc/moblock/moblock.conf && \
	echo "."
	}
[ ! -f /etc/default/moblock ] || { \
	echo -n "Loading and backuping /etc/default/moblock"
	. /etc/default/moblock && \
	rm /etc/default/moblock && \
	echo "."
	}
[ -z "$MOBLOCK_CRON" ] || CRON="$MOBLOCK_CRON"
[ -z "$MOBLOCK_INIT" ] || INIT="$MOBLOCK_INIT"
# Set back to blockcontrol values again (these variables are used later in this script):
CONTROL_CONF="/etc/blockcontrol/blockcontrol.conf"
CONTROL_DEFAULTS="/usr/lib/blockcontrol/blockcontrol.defaults"
BLOCKLISTS_LIST="/etc/blockcontrol/blocklists.list"

# Store values from configuration files into debconf db.
for VAR in $VARIABLES ; do
	# We don't need to check if the variable is set, because we also source 
	# blockcontrol.defaults, where all variables are set.
	# TODO: This has to be changed if the debconf part is moved to config again (then it can run,
	# before any variable is set).
	eval VALUE=\$$VAR
	case "$VAR" in

		'BLOCKLIST_FORMAT')
			case "$VALUE" in
				'd')
					db_set blockcontrol/$VAR 'eMule ipfilter.dat format'
					LISTS_POSSIBLE="$LISTS_DAT"
					;;
				'n')
					db_set blockcontrol/$VAR 'PeerGuardian .p2b v2 binary format'
					LISTS_POSSIBLE=""
					;;
				'p')
					db_set blockcontrol/$VAR 'PeerGuardian .p2p text format'
					LISTS_POSSIBLE="$LISTS_P2P"
					;;
			esac

			# Set the blocklists to be used.
			[ -f "$BLOCKLISTS_LIST" ] && {
				# Gives possible lists separated with |:
				LISTS_POSSIBLE_PIPE="$(echo $LISTS_POSSIBLE | sed 's/\ /|/g')"
				# Read the non-comment|not-empty lines from BLOCKLISTS_LIST:
				set_LISTS_URL
				for LIST in $LISTS_URL ; do
					# This function depends on LIST:
					LIST_URL2LIST_NAME
					# LIST_URL is empty, if LIST is notimestamp or locallist - so we can continue with the next LIST.
					[ -z "$LIST_URL" ] && continue
					# Gives currently selected (=configured in blocklists.list and known by debconf) lists:
					LISTS_SET="$LISTS_SET $(echo $LIST_NAME | grep -Eo "$LISTS_POSSIBLE_PIPE" || true)"
				done
				# Gives currently selected lists separated with ", " for debconf:
				LISTS_SET_COMMA="$(echo $LISTS_SET | sed 's/\ /,\ /g')"
				case "$VALUE" in
					'd')
						db_set blockcontrol/blocklists_dat "$LISTS_SET_COMMA"
						;;
					'p')
						db_set blockcontrol/blocklists_p2p "$LISTS_SET_COMMA"
						;;
				esac
			} || true
			;;

		'LOG_IPTABLES')
			case "$VALUE" in
				'')
					db_set blockcontrol/$VAR 'Do not log blocked packets to syslog.'
					;;
				'LOG --log-level info')
					db_set blockcontrol/$VAR 'Log blocked packets to syslog.'
					;;
				*)
					db_set blockcontrol/$VAR 'Do not touch my settings. Use the current custom value instead.'
					;;
			esac
			;;

		'VERBOSITY')
			case "$VALUE" in
				'0')
					db_set blockcontrol/$VAR 'Output to STDOUT is off (only errors will be reported).'
					;;
				'1')
					db_set blockcontrol/$VAR 'Output to STDOUT is on.'
					;;
				'2')
					db_set blockcontrol/$VAR 'Output to STDOUT is on but no warning will be shown if an operation is configured not to be executed.'
					;;
			esac
			;;

		'IPTABLES_SETTINGS')
			case "$VALUE" in
				'0')
					db_set blockcontrol/$VAR 'Do not set any iptables rules. You or another script/firewall has to do this!'
					;;
				'1')
					db_set blockcontrol/$VAR 'Use separate iptables chains.'
					;;
				'2')
					db_set blockcontrol/$VAR 'Only set custom iptables rules.'
					;;
			esac
			;;

		'IPTABLES_ACTIVATION')
			case "$VALUE" in
				'0')
					db_set blockcontrol/$VAR 'Do nothing. You or another script/firewall has to do this!'
					;;
				'1')
					db_set blockcontrol/$VAR 'Send all NEW traffic to the iptables chains of MoBlock.'
					;;
				'2')
					db_set blockcontrol/$VAR 'Send all traffic to the iptables chains of MoBlock.'
					;;
			esac
			;;

		'REJECT_IN'|'REJECT_OUT'|'REJECT_FW')
			case "$VALUE" in
				'DROP'|'REJECT')
					db_set blockcontrol/$VAR "$VALUE"
					;;
				*)
					db_set blockcontrol/$VAR 'Do not touch my settings. Use the current custom value instead.'
					;;
			esac
			;;

		'WHITE_LOCAL')
			case "$VALUE" in
				'0')
					db_set blockcontrol/$VAR 'No automatic whitelisting.'
					;;
				'1')
					db_set blockcontrol/$VAR 'Automatic whitelisting of LAN and DNS server and loopback device.'
					;;
				'2')
					db_set blockcontrol/$VAR 'Automatic whitelisting of DNS server and loopback device.'
					;;
			esac
			;;

		# For boolean variables:
		'LOG_SYSLOG'|'LOG_TIMESTAMP'|'INIT'|'CRON'|'REJECT'|'ACCEPT')
			case "$VALUE" in
				'0')
					db_set blockcontrol/$VAR false
					;;
				'1')
					db_set blockcontrol/$VAR true
					;;
				*)
					echo "WARNING: unknown value (\"$VALUE\") for $VAR. Ignoring."
					;;
			esac
			;;

		# For all other variables:
		*)
			db_set blockcontrol/$VAR $VALUE
			;;
	esac
done
# Set "Add line to allowlist" to empty value because adding the same
# line several times does not make much sense.
db_set blockcontrol/allowlist





# Ask debconf's questions.

# Transition from moblock-control 1.2 to blockcontrol 1.3:
if [ -e /etc/moblock/iptables-custom-insert.sh ] || [ -e /etc/moblock/iptables-custom-remove.sh ] ; then
	db_input critical blockcontrol/transition_moblock-control || true
fi

STATE=1
DONTSET=0	# Used for variables that do their own db_go
while true ; do
	case "$STATE" in
	'1')
		db_input high blockcontrol/warning_block || true
		;;
	'2')	
		db_input high blockcontrol/warning_firewall || true
		;;
	'3')
		db_input low blockcontrol/BLOCKLIST_FORMAT || true
		;;
	'4')
		db_get blockcontrol/BLOCKLIST_FORMAT
		if [ "$RET" = 'eMule ipfilter.dat format' ] ; then
			db_input high blockcontrol/blocklists_dat || true
		elif [ "$RET" = 'PeerGuardian .p2p text format' ] ; then
			db_input high blockcontrol/blocklists_p2p || true
		fi
		;;
	'5')
		db_input low blockcontrol/LOG_TIMESTAMP || true
		db_input low blockcontrol/LOG_SYSLOG || true
		db_input low blockcontrol/LOG_IPTABLES || true
		db_input low blockcontrol/VERBOSITY || true
		;;
	'6')
		db_input high blockcontrol/INIT || true
		db_input high blockcontrol/CRON || true
		;;
	'7')	# This part contains the db_go here instead of at the end of the function.
		db_input low blockcontrol/NFQUEUE_NUMBER && RETVAL=$? || { RETVAL=$? ; true ; }
		if db_go ; then
			# Check for valid setting, otherwise ask again
			db_get blockcontrol/NFQUEUE_NUMBER
			if [ "$RET" -ge 0 ] && [ "$RET" -le 65535 ] ; then
				# Continue if value is valid
				STATE=$(($STATE + 1))
			elif [ "$RETVAL" -eq 30 ] ; then
				# Break if value is not valid but we're in non-interactive mode
				echo "Invalid NFQUEUE_NUMBER settings, aborting."
				break
			else
				echo "Invalid NFQUEUE_NUMBER setting, choose a number between 0 and 65535."
			fi	
		else
			STATE=$(($STATE - 1))
		fi
		DONTSET=1
		;;
	'8')
		db_input low blockcontrol/IPTABLES_SETTINGS || true
		;;
	'9')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input low blockcontrol/IPTABLES_ACTIVATION || true
		fi
		;;
	'10')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input low blockcontrol/REJECT || true
		fi
		;;
	'11')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_get blockcontrol/REJECT
			if [ "$RET" = true ] ; then
				db_input low blockcontrol/REJECT_IN || true
				db_input low blockcontrol/REJECT_OUT || true
				db_input low blockcontrol/REJECT_FW || true
			fi
		fi
		;;
	'12')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input low blockcontrol/ACCEPT || true
		fi
		;;
	'13')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input high blockcontrol/info_whitelisting || true
		fi
		;;
	'14')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input high blockcontrol/WHITE_TCP_OUT || true
			db_input low blockcontrol/WHITE_UDP_OUT || true
			db_input low blockcontrol/WHITE_TCP_IN || true
			db_input low blockcontrol/WHITE_UDP_IN || true
			db_input low blockcontrol/WHITE_TCP_FORWARD || true
			db_input low blockcontrol/WHITE_UDP_FORWARD || true
		fi
		;;
	'15')
		db_get blockcontrol/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains." ] ; then
			db_input high blockcontrol/WHITE_LOCAL || true
			db_input high blockcontrol/allowlist || true
			db_input low blockcontrol/IP_REMOVE || true
		fi
		;;
	*)
		# The default case catches when $STATE is greater than the
		# last implemented state, and breaks out of the loop. This
		# requires that states be numbered consecutively from 1
		# with no gaps, as the default case will also be entered
		# if there is a break in the numbering
		break # exits the enclosing "while" loop
		;;
	esac
	# Go on in the state machine. If DONTSET is set a question did handle this on its own.
	[ "$DONTSET" -eq 1 ] && DONTSET=0 || {
		if db_go ; then
			STATE=$(($STATE + 1))
		elif [ "$STATE" -eq 1 ]; then
			# The user has asked to back up from the first
			# question. This case is problematical. Regular
			# dpkg and apt package installation isnâ€™t capable
			# of backing up questions between packages as this
			# is written, so this will exit leaving the package
			# unconfigured - probably the best way to handle
			# the situation.
			exit 10
		else
			STATE=$(($STATE - 1))
		fi
	}
done





# Define function for debconf's db_get. Usage my_db_get $1, where $1 is the
# variable set in debconf. The name of the package is already set within this
# function.
# Check if $RET contains invalid signs.
my_db_get () {
	# Test if exactly $1 was specified.
	[ "$#" = 1 ] || { echo "Internal script error. Aborting."; exit 1; }
	db_get blockcontrol/$1
	case "$RET" in
		*\|*)
			echo "WARNING: This script does not allow to use pipes (\"|\")."
			echo "You have set $1 to \"$RET\" which does contain a pipe."
			echo "Therefore not changing this variable."
			;;
		*)
			# If the value is set in blockcontrol.conf, then set it there:
			if [ -f "$CONTROL_CONF" ] && grep -Eq "^[[:space:]]*$1=" $CONTROL_CONF ; then
				CONFFILE=$CONTROL_CONF
			else
				CONFFILE=$CONTROL_DEFAULTS
			fi
			;;
	esac
}





# Substitute in the values from the debconf db.
# See `man debconf-devel`
# Non-default values will be set in default.
# Default values will be set in default if they were set there already,
# otherwise they will be set in blockcontrol.conf

my_db_get BLOCKLIST_FORMAT
case "$RET" in
	'eMule ipfilter.dat format')
		# Set blocklist format
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"d\"|" $CONTROL_CONF
		else
			echo "BLOCKLIST_FORMAT=\"d\"" >> $CONTROL_CONF
		fi
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_DAT"
		# Define lists that are incompatible with this format:
		# The bluetack ipfilters aren't downloadable anymore (Dec. 2008).
		LISTS_X="$LISTS_P2B $LISTS_P2P"
		# Get the selected lists for this blocklist format:
		db_get blockcontrol/blocklists_dat
		;;
	'PeerGuardian .p2b v2 binary format')
		# Set blocklist format
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"n\"|" $CONTROL_CONF
		else
			echo "BLOCKLIST_FORMAT=\"n\"" >> $CONTROL_CONF
		fi
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_P2B"
		# Define lists that are incompatible with this format:
		LISTS_X="$LISTS_DAT $LISTS_P2P"
		# Get the selected lists for this blocklist format - no debconf here, yet:
		RET=""
		;;
	'PeerGuardian .p2p text format')	# Default
		# Set blocklist format
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"p\"|" $CONTROL_CONF
		fi
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_P2P"
		# Define lists that are incompatible with this format:
		LISTS_X="$LISTS_DAT $LISTS_P2B"
		# Get the selected lists for this blocklist format:
		db_get blockcontrol/blocklists_p2p
		;;
esac

# $RET of the previous db_get gives selected lists seperated with (", ").
# If all lists were deselected replace empty value with dummy, otherwise
# LISTS_XGET will stay empty although it should contain all LISTs:
LISTS_GET_NAME_COMMA=${RET:-dummy}
LISTS_GET_NAME="$(echo $LISTS_GET_NAME_COMMA | sed 's/,//g')"

# Add (if necessary) selected blocklists to blocklists.list
for LIST_NAME in $LISTS_GET_NAME ; do
	# Translate human readable/debconf LIST_NAME to LIST_URL.
	LIST_NAME2LIST_URL
	# Add selected lists to blocklists.list
	if [ "$LIST_URL" = dummy ] ; then
		# just ignore the dummy
		true
	elif grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX" $BLOCKLISTS_LIST ; then
		# LIST_URL is already selected.
		# If the already selected list is used with the deprecated notimestamp option
		# we're fine, too.
		true
	elif LIST_NAME2LIST_URL_ALT && [ -n "$LIST_URL_ALT" ] && grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT" $BLOCKLISTS_LIST ; then
		# LIST_URL_ALT is already selected with an alternative URL.
		# If the already selected list is used with the deprecated notimestamp option
		# we're fine, too
		true
	elif grep -Eq "^#(http://)?$LIST_URL_REGEX$" $BLOCKLISTS_LIST ; then
		# LIST is commented, uncomment it.
		# The REGEX is very strict, so that no user changes get lost.
		# An occurence of http:// is kept on uncommenting.
		sed -i -r "s|^#((http://)?$LIST_URL_REGEX)$|\1|" $BLOCKLISTS_LIST
	else
		# LIST is not in blocklists.list (at least not in the very strict form described before).
		echo >> $BLOCKLISTS_LIST
		echo "# Added by debconf:" >> $BLOCKLISTS_LIST
		echo $LIST_URL >> $BLOCKLISTS_LIST
	fi
done

# Gives selected lists seperated with "|":
LISTS_GET_NAME_PIPE="$(echo $LISTS_GET_NAME | sed "s/\ /\|/g")"
for LIST_NAME in $LISTS_POSSIBLE ; do
	# Gives deselected (known to debconf but not configured to be used) lists seperated with space:
	LISTS_XGET="$LISTS_XGET $(echo $LIST_NAME | grep -Ev $LISTS_GET_NAME_PIPE || true)"
done

# These lists were either deselected or are in an incompatible format:
for LIST_NAME in $LISTS_XGET $LISTS_X ; do
	# Translate human readable/debconf LIST_NAME to LIST_URL.
	LIST_NAME2LIST_URL
	LIST_NAME2LIST_URL_ALT
	# Remove deselected and known incompatible lists from blocklists.list
	if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX" $BLOCKLISTS_LIST ; then
		# LIST_NAME is currently selected, add a # in front of pattern
		sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX|#&|" $BLOCKLISTS_LIST
	fi
	if [ -n "$LIST_URL_ALT" ] && grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT" $BLOCKLISTS_LIST ; then	# List is currently selected
		# LIST_NAME is currently selected with alternative URL, add a # in front of pattern
		sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT|#&|" $BLOCKLISTS_LIST
	fi
done

# Unavailable lists:
if [ "$BLOCKLIST_FORMAT" = d ] ; then
	for LIST_URL in www.bluetack.co.uk/config/nipfilter.dat.gz www.bluetack.co.uk/config/pipfilter.dat.gz ; do
		if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL" $BLOCKLISTS_LIST ; then
			echo -n "Disabling $LIST_URL because it is no more downloadable directly"
			sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL|# Disabled because list is no more downloadable directly: &|" $BLOCKLISTS_LIST
			echo "."
		fi
	done
fi

my_db_get LOG_TIMESTAMP
case "$RET" in
	'false')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_TIMESTAMP=.*|LOG_TIMESTAMP=\"0\"|" $CONTROL_CONF
		else
			echo "LOG_TIMESTAMP=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'true')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_TIMESTAMP=.*|LOG_TIMESTAMP=\"1\"|" $CONTROL_CONF
		fi
		;;
esac

my_db_get LOG_SYSLOG
case "$RET" in
	'false')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_SYSLOG=.*|LOG_SYSLOG=\"0\"|" $CONTROL_CONF
		fi
		;;
	'true')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_SYSLOG=.*|LOG_SYSLOG=\"1\"|" $CONTROL_CONF
		else
			echo "LOG_SYSLOG=\"1\"" >> $CONTROL_CONF
		fi
		;;
esac

my_db_get LOG_IPTABLES
case "$RET" in
	'Do not log blocked packets to syslog.')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_IPTABLES=.*|LOG_IPTABLES=\"\"|" $CONTROL_CONF
		fi
		;;
	'Log blocked packets to syslog.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_IPTABLES=.*|LOG_IPTABLES=\"LOG --log-level info\"|" $CONTROL_CONF
		else
			echo "LOG_IPTABLES=\"LOG --log-level info\"" >> $CONTROL_CONF
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get VERBOSITY
case "$RET" in
	'Output to STDOUT is off (only errors will be reported).')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"0\"|" $CONTROL_CONF
		else
			echo "VERBOSITY=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'Output to STDOUT is on.')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"1\"|" $CONTROL_CONF
		fi
		;;
	'Output to STDOUT is on but no warning will be shown if an operation is configured not to be executed.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"2\"|" $CONTROL_CONF
		else
			echo "VERBOSITY=\"2\"" >> $CONTROL_CONF
		fi
		;;
esac

my_db_get INIT
case "$RET" in
	'false')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*INIT=.*|INIT=\"0\"|" $CONTROL_CONF
		else
			echo "INIT=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'true')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*INIT=.*|INIT=\"1\"|" $CONTROL_CONF
		fi
		;;
esac

my_db_get CRON
case "$RET" in
	'false')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*CRON=.*|CRON=\"0\"|" $CONTROL_CONF
		else
			echo "CRON=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'true')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*CRON=.*|CRON=\"1\"|" $CONTROL_CONF
		fi
		;;
esac

my_db_get NFQUEUE_NUMBER
if [ "$RET" = 92 ] ; then	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*NFQUEUE_NUMBER=.*|NFQUEUE_NUMBER=\"$RET\"|" $CONTROL_CONF
	fi
else
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*NFQUEUE_NUMBER=.*|NFQUEUE_NUMBER=\"$RET\"|" $CONTROL_CONF
	else
		echo "NFQUEUE_NUMBER=\"$RET\"" >> $CONTROL_CONF
	fi
fi

my_db_get IPTABLES_SETTINGS
case "$RET" in
	'Do not set any iptables rules. You or another script/firewall has to do this!')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"0\"|" $CONTROL_CONF
		else
			echo "IPTABLES_SETTINGS=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'Use separate iptables chains.')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"1\"|" $CONTROL_CONF
		fi
		;;
	'Only set custom iptables rules.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"2\"|" $CONTROL_CONF
		else
			echo "IPTABLES_SETTINGS=\"2\"" >> $CONTROL_CONF
		fi
		;;
esac

my_db_get IPTABLES_ACTIVATION
case "$RET" in
	'Do nothing. You or another script/firewall has to do this!')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"0\"|" $CONTROL_CONF
		else
			echo "IPTABLES_ACTIVATION=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'Send all NEW traffic to the iptables chains of MoBlock.')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"1\"|" $CONTROL_CONF
		fi
		;;
	'Send all traffic to the iptables chains of MoBlock.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"2\"|" $CONTROL_CONF
		else
			echo "IPTABLES_ACTIVATION=\"2\"" >> $CONTROL_CONF
		fi
		;;
esac

my_db_get REJECT
case "$RET" in
	'false')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT=.*|REJECT=\"0\"|" $CONTROL_CONF
		else
			echo "REJECT=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'true')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT=.*|REJECT=\"1\"|" $CONTROL_CONF
		fi
		;;
esac

my_db_get REJECT_IN
case "$RET" in
	'DROP')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_IN=.*|REJECT_IN=\"$RET\"|" $CONTROL_CONF
		fi
		;;
	'REJECT')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_IN=.*|REJECT_IN=\"$RET\"|" $CONTROL_CONF
		else
			echo "REJECT_IN=\"$RET\"" >> $CONTROL_CONF
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get REJECT_OUT
case "$RET" in
	'DROP')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_OUT=.*|REJECT_OUT=\"$RET\"|" $CONTROL_CONF
		else
			echo "REJECT_OUT=\"$RET\"" >> $CONTROL_CONF
		fi
		;;
	'REJECT')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_OUT=.*|REJECT_OUT=\"$RET\"|" $CONTROL_CONF
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get REJECT_FW
case "$RET" in
	'DROP')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_FW=.*|REJECT_FW=\"$RET\"|" $CONTROL_CONF
		fi
		;;
	'REJECT')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_FW=.*|REJECT_FW=\"$RET\"|" $CONTROL_CONF
		else
			echo "REJECT_FW=\"$RET\"" >> $CONTROL_CONF
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get ACCEPT
case "$RET" in
	'false')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*ACCEPT=.*|ACCEPT=\"0\"|" $CONTROL_CONF
		else
			echo "ACCEPT=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'true')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*ACCEPT=.*|ACCEPT=\"1\"|" $CONTROL_CONF
		fi
		;;
esac

my_db_get WHITE_TCP_OUT
if [ -z "$RET" ] ; then	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_OUT=.*|WHITE_TCP_OUT=\"\"|" $CONTROL_CONF
	fi
else
	# change port numbers to associated service name because of mobloquer (0.5) bug.
	RET_FIXED="$(echo $RET | sed "s|^80 443|http https|")"
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_OUT=.*|WHITE_TCP_OUT=\"$RET_FIXED\"|" $CONTROL_CONF
	else
		echo "WHITE_TCP_OUT=\"$RET_FIXED\"" >> $CONTROL_CONF
	fi
fi

my_db_get WHITE_UDP_OUT
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_OUT=.*|WHITE_UDP_OUT=\"$RET\"|" $CONTROL_CONF
	else
		echo "WHITE_UDP_OUT=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_UDP_OUT=.*|WHITE_UDP_OUT=\"$RET\"|" $CONTROL_CONF
		fi
fi

my_db_get WHITE_TCP_IN
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_IN=.*|WHITE_TCP_IN=\"$RET\"|" $CONTROL_CONF
	else
		echo "WHITE_TCP_IN=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_IN=.*|WHITE_TCP_IN=\"$RET\"|" $CONTROL_CONF
	fi
fi

my_db_get WHITE_UDP_IN
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_IN=.*|WHITE_UDP_IN=\"$RET\"|" $CONTROL_CONF
	else
		echo "WHITE_UDP_IN=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_IN=.*|WHITE_UDP_IN=\"$RET\"|" $CONTROL_CONF
	fi
fi

my_db_get WHITE_TCP_FORWARD
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_FORWARD=.*|WHITE_TCP_FORWARD=\"$RET\"|" $CONTROL_CONF
	else
		echo "WHITE_TCP_FORWARD=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_FORWARD=.*|WHITE_TCP_FORWARD=\"$RET\"|" $CONTROL_CONF
	fi
fi

my_db_get WHITE_UDP_FORWARD
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_FORWARD=.*|WHITE_UDP_FORWARD=\"$RET\"|" $CONTROL_CONF
	else
		echo "WHITE_UDP_FORWARD=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_FORWARD=.*|WHITE_UDP_FORWARD=\"$RET\"|" $CONTROL_CONF
	fi
fi

my_db_get WHITE_LOCAL
case "$RET" in
	'No automatic whitelisting.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"0\"|" $CONTROL_CONF
		else
			echo "WHITE_LOCAL=\"0\"" >> $CONTROL_CONF
		fi
		;;
	'Automatic whitelisting of LAN and DNS server and loopback device.')	# Default
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"1\"|" $CONTROL_CONF
		fi
		;;
	'Automatic whitelisting of DNS server and loopback device.')
		if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"2\"|" $CONTROL_CONF
		else
			echo "WHITE_LOCAL=\"2\"" >> $CONTROL_CONF
		fi
		;;
esac

my_db_get IP_REMOVE
if [ -n "$RET" ] ; then
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*IP_REMOVE=.*|IP_REMOVE=\"$RET\"|" $CONTROL_CONF
	else
		echo "IP_REMOVE=\"$RET\"" >> $CONTROL_CONF
	fi
else	# Default
	if [ "$CONFFILE" = "$CONTROL_CONF" ] ; then
		sed -i -r "s|^[[:space:]]*IP_REMOVE=.*|IP_REMOVE=\"$RET\"|" $CONTROL_CONF
	fi
fi

# Load new configuration. (CONTROL_DEFAULTS has to be loaded again, because we loaded the moblock-control settings before!)
# The automatic NAME detection 
if [ -f "$CONTROL_DEFAULTS" ] ; then
	. $CONTROL_DEFAULTS || { echo "Error: Failed to source $CONTROL_DEFAULTS although this file exists."; exit 1; }
fi
if [ -f "$CONTROL_CONF" ] ; then
	. $CONTROL_CONF || { echo "Error: Failed to source $CONTROL_CONF although this file exists."; exit 1; }
fi

# Add a line to the allow list.
# The configuration files must have been sourced already for this!
db_get blockcontrol/allowlist
[ -z "$RET" ] || {
	echo "" >> "$ALLOW_OUT"	# add newline first in case the current file lacks one!
	echo $RET >> "$ALLOW_OUT"
	if [ -n "$ALLOW_IN" ] && [ "$ALLOW_IN" != "$ALLOW_OUT" ] ; then
		echo "" >> "$ALLOW_IN"	# add newline first in case the current file lacks one!
		echo $RET >> "$ALLOW_IN"
	fi
	if [ -n "$ALLOW_FW" ] && [ "$ALLOW_FW" != "$ALLOW_OUT" ] ; then
		echo "" >> "$ALLOW_FW"	# add newline first in case the current file lacks one!
		echo $RET >> "$ALLOW_FW"
	fi
}

# done with debconf...
db_stop

# End of substitute in the values from the debconf db.





# Test correct BLOCKLIST_FORMAT setting.
# Set the blocklist name depending on the type of the blocklist (configuration setting).
test_set_BLOCKLIST

# Move blocklists from old moblock-control places. The update path is only clean from 1.2. Lists downloaded earlier
# will stay at their places and a new download for blockcontrol is necessary.
for i in ipfilter.dat guarding.p2b guarding.p2p ipfilter.dat.backup guarding.p2b.backup guarding.p2p.backup ; do
	[ -f /var/lib/moblock/$i ] && mv /var/lib/moblock/$i /var/lib/blockcontrol/
done
[ "$( ls /var/spool/moblock/ | wc -l )" -eq 0 ] || mv /var/spool/moblock/* /var/spool/blockcontrol/

if [ "$INIT" -ne 0 ] && [ -x "/etc/init.d/blockcontrol" ] ; then
	# dh_installdeb inserts code to execute init "start".
	echo
	echo "$DESC will soon be started ..."
	echo "If any blocklists are missing, they will be downloaded. This may take several"
	echo "minutes. Please be patient and don't abort. If you want to follow the update"
	echo "process, then do in another terminal a"
	echo " tail -f $CONTROL_LOG"
	echo "The lists are saved to $BLOCKLISTS_DIR/."
	echo "The installation of $CONTROL_NAME will fail, if starting $DESC fails. If this"
	echo "happens, then in most cases downloading the blocklists failed temporarily. To"
	echo "workaround this, you can turn the automatic starting of $DESC off by setting"
	echo "in $CONTROL_CONF:"
	echo " INIT=\"0\""
	echo
fi

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
