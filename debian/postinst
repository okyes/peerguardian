#!/bin/sh
# postinst script for blockcontrol
# see: dh_installdeb(1)

# Copyright (C) 2008 - 2009 jre <jre-phoenix@users.sourceforge.net>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

set -e
# summary of how this script can be called:
#	* <postinst> `configure' <most-recently-configured-version>
#	* <old-postinst> `abort-upgrade' <new version>
#	* <conflictor's-postinst> `abort-remove' `in-favour' <package>
#	  <new-version>
#	* <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#	  <failed-install-package> <version> `removing'
#	  <conflicting-package> <version>
# for details, see http://www.debian.org/doc/debian-policy/ or
# the debian-policy package

# Note: Some of the following code is normally placed in debian/config and some
# would need to be present in both files.

# Source debconf library.
. /usr/share/debconf/confmodule

db_version 2.0

# This (deb)conf script is capable of backing up
db_capb backup

case "$1" in
	configure|reconfigure)
		true	# continue below
		;;
	abort-upgrade|abort-remove|abort-deconfigure)
		exit 0
		;;
	*)
		echo "postinst called with unknown argument \"$1\"" >&2
		exit 1
		;;
esac

################################################################################
# The following code is common between blockcontrol, init, cron.daily,
# if-up and debian/postinst.
# It sets/loads the variables and functions

# These two variables have to be set correctly in all just mentioned files.
# Everything else can then be done in blockcontrol.conf.
CONTROL_CONF="/etc/blockcontrol.conf"
CONTROL_DEFAULTS="/usr/lib/defaults"

# Remember standard IFS (Internal Field Seperator)
STDIFS=$IFS

# Set sane configuration defaults. They will be overwritten by the values in
# CONTROL_CONF and CONTROL_DEFAULT
if [ -f "$CONTROL_DEFAULTS" ] ; then
	. $CONTROL_DEFAULTS || { echo "Error: Failed to source $CONTROL_DEFAULTS although this file exists."; exit 1; }
else
	echo "Error 7: Missing file $CONTROL_DEFAULTS."
	exit 7
fi

# Check what daemon is installed in PATH and set variables accordingly.
# We first need to know the NAME, so this needs to be the first thing we do.
NAME=
DAEMON=
DESC=
IFS=":"
for PATH_I in $PATH ; do
	if [ -x "$PATH_I/moblock" ] ; then
		NAME="moblock"
		DAEMON="$PATH_I/moblock"
		DESC="MoBlock"
		break
	elif [ -x "$PATH_I/nfblock" ] ; then
		NAME="nfblock"
		DAEMON="$PATH_I/$NAME"
		DESC="NFblock"
		break
	fi
done
IFS=$STDIFS

# Load configuration. This overwrites the above values.
if [ -f "$CONTROL_CONF" ] ; then
	. $CONTROL_CONF || { echo "Error: Failed to source $CONTROL_CONF although this file exists."; exit 1; }
else
	[ -d "$(dirname $CONTROL_CONF)" ] || {
		echo -n "Creating missing directory $(dirname $CONTROL_CONF)"
		mkdir "$(dirname $CONTROL_CONF)" && echo "."
		} || {
		log_failure_msg "Error $E_XCD: Missing directory "$(dirname $CONTROL_CONF)"."
		log_failure_msg "Check the CONTROL_CONF setting in $0."
		exit $E_XCD
	}
	echo -n "Creating missing $CONTROL_CONF"
	echo "# blockcontrol.conf - configuration file for blockcontrol" > $CONTROL_CONF
	echo "# This file was created automatically by $0." >> $CONTROL_CONF
	echo "" >> $CONTROL_CONF
	echo "# This file is sourced by a shell script. Any line which starts with a # (hash) " >> $CONTROL_CONF
	echo "# is a comment and is ignored. If you set the same variable several times," >> $CONTROL_CONF
	echo "# then only the last line will be used. You have to stop and restart $NAME" >> $CONTROL_CONF
	echo "# if you change entries." >> $CONTROL_CONF
	echo "" >> $CONTROL_CONF
	echo "# Values from this file (blockcontrol.conf) will be overwritten by default" >> $CONTROL_CONF
	echo "# (/etc/default/blockcontrol) if they are set there." >> $CONTROL_CONF
	echo "."
fi

# Load default configuration. This overwrites the above values.
if [ -f "$CONTROL_DEFAULT" ] ; then
	. $CONTROL_DEFAULT || { echo "Error: Failed to source $CONTROL_DEFAULT although this file exists."; exit 1; }
else
	[ -d "$(dirname $CONTROL_DEFAULT)" ] || {
		echo -n "Creating missing directory $(dirname $CONTROL_DEFAULT)"
		mkdir "$(dirname $CONTROL_DEFAULT)" && echo "."
		} || {
		log_failure_msg "Error $E_XCD: Missing directory "$(dirname $CONTROL_CONF)"."
		log_failure_msg "Check the CONTROL_DEFAULT setting in $0."
		exit $E_XCD
	}
	echo -n "Creating missing $CONTROL_DEFAULT"
	echo "# default - default configuration file for blockcontrol" >> $CONTROL_DEFAULT
	echo "# This file was created automatically by $0." >> $CONTROL_DEFAULT
	echo "" >> $CONTROL_DEFAULT
	echo "# In this file you can put any configuration variable from blockcontrol.conf" >> $CONTROL_DEFAULT
	echo "# ($CONTROL_CONF). Values in blockcontrol.conf will be overwritten by" >> $CONTROL_DEFAULT
	echo "# values in this file (default)." >> $CONTROL_DEFAULT
	echo "" >> $CONTROL_DEFAULT
	echo "# Do a \"blockcontrol restart\" when you have edited this file." >> $CONTROL_DEFAULT
	echo "" >> $CONTROL_DEFAULT
	echo "."
fi

# If the daemon was neither found, nore set manually, then abort now.
if [ -z $NAME ] || [ -z $DAEMON ] || [ -z $DESC ] ; then
	echo "Could not detect an IPBlocker daemon. MoBlock and NFBlock are supported."
	echo "Neither of them was found in PATH: $PATH."
	echo "Error $E_CONFIG: You may set NAME, DAEMON and DESC manually in $CONTROL_CONF."
	exit $E_CONFIG
fi

# Load blockcontrol library.
if [ -f "$SCRIPT_LIB" ] ; then
	. $SCRIPT_LIB || { echo "Error: Failed to source $SCRIPT_LIB although this file exists."; exit 1; }
else
	echo "Error $E_CONFIG: You need $SCRIPT_LIB."
	exit $E_CONFIG
fi

load_lsb

# End of the common code between blockcontrol, init, cron.daily,
# if-up and debian/postinst.
################################################################################

VARIABLES="
	BLOCKLIST_FORMAT
	LOG_TIMESTAMP
	LOG_SYSLOG
	LOG_IPTABLES
	VERBOSITY
	INIT
	CRON
	NFQUEUE_NUMBER
	IPTABLES_SETTINGS
	IPTABLES_ACTIVATION
	REJECT
	REJECT_IN
	REJECT_OUT
	REJECT_FW
	ACCEPT
	WHITE_LOCAL
	WHITE_TCP_OUT
	WHITE_UDP_OUT
	WHITE_TCP_IN
	WHITE_UDP_IN
	WHITE_TCP_FORWARD
	WHITE_UDP_FORWARD
	IP_REMOVE"

# Known lists in .dat format.
LISTS_DAT="
	tbg.iblocklist.com/Lists/ipfilter.dat.gz"

LISTS_P2B=""

# Known lists in .p2p format.
# Make sure LIST_NAME is also in debian/templates and LIST_NAME2LIST_URL
# For moving the lists from the old places (v.1.1) postinst also needs them to
# be in LIST_NAME2LIST_URL_ALT.
LISTS_P2P="
	Bluetack_level1
	Bluetack_level2
	Bluetack_level3
	Bluetack_edu
	Bluetack_ads
	Bluetack_bogon
	Bluetack_spyware
	Bluetack_spider
	Bluetack_Microsoft
	Bluetack_proxy
	Bluetack_hijacked
	Bluetack_badpeers
	Bluetack_rangetest
	Bluetack_dshield
	TBG_Primary_Threats
	TBG_General_Corporate_Ranges
	TBG_Business_ISPs
	TBG_Educational_Institutions
	TBG_Search_Engines
	TBG_Hijacked
	TBG_Bogon"

# Rename lists as bluetack did it:
if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?www.bluetack.co.uk/config/templist" $BLOCKLISTS_LIST ; then
	echo -n "Renaming list templist to badpeers like bluetack.co.uk did it..."
	sed -i -r "s|www.bluetack.co.uk/config/templist|www.bluetack.co.uk/config/badpeers|" $BLOCKLISTS_LIST
	echo "done."
fi

# Store values from configuration files into debconf db.
for VAR in $VARIABLES ; do
	# value will only be set if the variable is known (This makes sure
	# that on the introduction of new variables the default is used and
	# not an empty value):
	# Note that the values were already loaded above, the following is 
	# just the test IF the variables are set in the config files.
	if ( [ -e $CONTROL_CONF ] && grep -Eq "^[[:space:]]*$VAR=" $CONTROL_CONF ) || \
	( [ -e $CONTROL_CONF ] && grep -Eq "^[[:space:]]*$VAR=" $CONTROL_DEFAULT ) ; then
		eval VALUE=\$$VAR
		case "$VAR" in

			'BLOCKLIST_FORMAT')
				case "$VALUE" in
					'd')
						db_set moblock/$VAR 'eMule ipfilter.dat format'
						LISTS_POSSIBLE="$LISTS_DAT"
						;;
					'n')
						db_set moblock/$VAR 'PeerGuardian .p2b v2 binary format'
						LISTS_POSSIBLE=""
						;;
					'p')
						db_set moblock/$VAR 'PeerGuardian .p2p text format'
						LISTS_POSSIBLE="$LISTS_P2P"
						;;
				esac

				# Set the blocklists to be used.
				[ -f "$BLOCKLISTS_LIST" ] && {
					# Gives possible lists separated with |:
					LISTS_POSSIBLE_PIPE="$(echo $LISTS_POSSIBLE | sed 's/\ /|/g')"
					# Read the non-comment|not-empty lines from BLOCKLISTS_LIST:
					set_LISTS_URL
					for LIST in $LISTS_URL ; do
						# This function depends on LIST:
						LIST_URL2LIST_NAME
						# LIST_URL is empty, if LIST is notimestamp or locallist - so we can continue with the next LIST.
						[ -z "$LIST_URL" ] && continue
						# Gives currently selected (=configured in blocklists.list and known by debconf) lists:
						LISTS_SET="$LISTS_SET $(echo $LIST_NAME | grep -Eo "$LISTS_POSSIBLE_PIPE" || true)"
					done
					# Gives currently selected lists separated with ", " for debconf:
					LISTS_SET_COMMA="$(echo $LISTS_SET | sed 's/\ /,\ /g')"
					case "$VALUE" in
						'd')
							db_set moblock/blocklists_dat "$LISTS_SET_COMMA"
							;;
						'p')
							db_set moblock/blocklists_p2p "$LISTS_SET_COMMA"
							;;
					esac
				} || true
				;;

			'LOG_IPTABLES')
				case "$VALUE" in
					'')
						db_set moblock/$VAR 'Do not log blocked packets to syslog.'
						;;
					'LOG --log-level info')
						db_set moblock/$VAR 'Log blocked packets to syslog.'
						;;
					*)
						db_set moblock/$VAR 'Do not touch my settings. Use the current custom value instead.'
						;;
				esac
				;;

			'VERBOSITY')
				case "$VALUE" in
					'0')
						db_set moblock/$VAR 'Output to STDOUT is off (only errors will be reported).'
						;;
					'1')
						db_set moblock/$VAR 'Output to STDOUT is on.'
						;;
					'2')
						db_set moblock/$VAR 'Output to STDOUT is on but no warning will be shown if an operation is configured not to be executed.'
						;;
				esac
				;;

			'IPTABLES_SETTINGS')
				case "$VALUE" in
					'0')
						db_set moblock/$VAR 'Do not set any iptables rules. You or another script/firewall has to do this!'
						;;
					'1')
						db_set moblock/$VAR 'Use separate iptables chains for MoBlock.'
						;;
					'2')
						db_set moblock/$VAR 'Only set custom iptables rules.'
						;;
				esac
				;;

			'IPTABLES_ACTIVATION')
				case "$VALUE" in
					'0')
						db_set moblock/$VAR 'Do nothing. You or another script/firewall has to do this!'
						;;
					'1')
						db_set moblock/$VAR 'Send all NEW traffic to the iptables chains of MoBlock.'
						;;
					'2')
						db_set moblock/$VAR 'Send all traffic to the iptables chains of MoBlock.'
						;;
				esac
				;;

			'REJECT_IN'|'REJECT_OUT'|'REJECT_FW')
				case "$VALUE" in
					'DROP'|'REJECT')
						db_set moblock/$VAR "$VALUE"
						;;
					*)
						db_set moblock/$VAR 'Do not touch my settings. Use the current custom value instead.'
						;;
				esac
				;;

			'WHITE_LOCAL')
				case "$VALUE" in
					'0')
						db_set moblock/$VAR 'Do nothing.'
						;;
					'1')
						db_set moblock/$VAR 'Automatically whitelist LAN traffic and traffic on the loopback device.'
						;;
					'2')
						db_set moblock/$VAR 'Whitelist the loopback device.'
						;;
				esac
				;;

			# For boolean variables:
			'LOG_SYSLOG'|'LOG_TIMESTAMP'|'INIT'|'CRON'|'REJECT'|'ACCEPT')
				case "$VALUE" in
					'0')
						db_set moblock/$VAR false
						;;
					'1')
						db_set moblock/$VAR true
						;;
					*)
						echo "WARNING: unknown value (\"$VALUE\") for $VAR. Ignoring."
						;;
				esac
				;;

			# For all other variables:
			*)
				db_set moblock/$VAR $VALUE
				;;

		esac
	fi
done
# Set "Add line to allowlist" to empty value because adding the same
# line several times does not make much sense.
db_set moblock/allowlist





# Ask debconf's questions.
STATE=1
DONTSET=0	# Used for variables that do their own db_go
while true ; do
	case "$STATE" in
	'1')
		db_input critical moblock/warning_block || true
		;;
	'2')	
		db_input critical moblock/warning_firewall || true
		;;
	'3')
		db_input low moblock/BLOCKLIST_FORMAT || true
		;;
	'4')
		db_get moblock/BLOCKLIST_FORMAT
		if [ "$RET" = 'eMule ipfilter.dat format' ] ; then
			db_input high moblock/blocklists_dat || true
		elif [ "$RET" = 'PeerGuardian .p2p text format' ] ; then
			db_input high moblock/blocklists_p2p || true
		fi
		;;
	'5')
		db_input low moblock/LOG_TIMESTAMP || true
		db_input low moblock/LOG_SYSLOG || true
		db_input low moblock/LOG_IPTABLES || true
		db_input low moblock/VERBOSITY || true
		;;
	'6')
		db_input medium moblock/INIT || true
		db_input medium moblock/CRON || true
		;;
	'7')	# This part contains the db_go here instead of at the end of the function.
		db_input low moblock/NFQUEUE_NUMBER && RETVAL=$? || { RETVAL=$? ; true ; }
		if db_go ; then
			# Check for valid setting, otherwise ask again
			db_get moblock/NFQUEUE_NUMBER
			if [ "$RET" -ge 0 ] && [ "$RET" -le 65535 ] ; then
				# Continue if value is valid
				STATE=$(($STATE + 1))
			elif [ "$RETVAL" -eq 30 ] ; then
				# Break if value is not valid but we're in non-interactive mode
				echo "Invalid NFQUEUE_NUMBER settings, aborting."
				break
			else
				echo "Invalid NFQUEUE_NUMBER setting, choose a number between 0 and 65535."
			fi	
		else
			STATE=$(($STATE - 1))
		fi
		DONTSET=1
		;;
	'8')
		db_input low moblock/IPTABLES_SETTINGS || true
		;;
	'9')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input low moblock/IPTABLES_ACTIVATION || true
		fi
		;;
	'10')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input low moblock/REJECT || true
		fi
		;;
	'11')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_get moblock/REJECT
			if [ "$RET" = true ] ; then
				db_input low moblock/REJECT_IN || true
				db_input low moblock/REJECT_OUT || true
				db_input low moblock/REJECT_FW || true
			fi
		fi
		;;
	'12')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input low moblock/ACCEPT || true
		fi
		;;
	'13')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input critical moblock/info_whitelisting || true
		fi
		;;
	'14')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input high moblock/WHITE_TCP_OUT || true
			db_input low moblock/WHITE_UDP_OUT || true
			db_input low moblock/WHITE_TCP_IN || true
			db_input low moblock/WHITE_UDP_IN || true
			db_input low moblock/WHITE_TCP_FORWARD || true
			db_input low moblock/WHITE_UDP_FORWARD || true
		fi
		;;
	'15')
		db_get moblock/IPTABLES_SETTINGS
		if [ "$RET" = "Use separate iptables chains for MoBlock." ] ; then
			db_input critical moblock/WHITE_LOCAL || true
			db_input critical moblock/allowlist || true
			db_input low moblock/IP_REMOVE || true
		fi
		;;
	*)
		# The default case catches when $STATE is greater than the
		# last implemented state, and breaks out of the loop. This
		# requires that states be numbered consecutively from 1
		# with no gaps, as the default case will also be entered
		# if there is a break in the numbering
		break # exits the enclosing "while" loop
		;;
	esac
	# Go on in the state machine. If DONTSET is set a question did handle this on its own.
	[ "$DONTSET" -eq 1 ] && DONTSET=0 || {
		if db_go ; then
			STATE=$(($STATE + 1))
		elif [ "$STATE" -eq 1 ]; then
			# The user has asked to back up from the first
			# question. This case is problematical. Regular
			# dpkg and apt package installation isnâ€™t capable
			# of backing up questions between packages as this
			# is written, so this will exit leaving the package
			# unconfigured - probably the best way to handle
			# the situation.
			exit 10
		else
			STATE=$(($STATE - 1))
		fi
	}
done





# Define function for debconf's db_get. Usage my_db_get $1, where $1 is the
# variable set in debconf. The name of the package is already set within this
# function.
# Check if $RET contains invalid signs.
# Readd variable to CONTROL_CONF if it is missing, so sed will work in any case later.
my_db_get () {
	# Test if exactly $1 was specified.
	[ "$#" = 1 ] || { echo "Internal script error. Aborting."; exit 1; }
	db_get moblock/$1
	case "$RET" in
		*\|*)
			echo "WARNING: This script does not allow to use pipes (\"|\")."
			echo "You have set $1 to \"$RET\" which does contain a pipe."
			echo "Therefore not changing this variable."
			;;
		*)
			# If the value is set in default then set it there:
			if [ -f "$CONTROL_DEFAULT" ] && grep -Eq "^[[:space:]]*$1=" $CONTROL_DEFAULT ; then
				FILE_TO_CHANGE=$CONTROL_DEFAULT
			else
				FILE_TO_CHANGE=$CONTROL_CONF
				# If the admin deleted or commented some variables
				# then (re-)add them to blockcontrol.conf.
				grep -Eq "^[[:space:]]*$1=" $CONTROL_CONF || {
					echo "" >> $CONTROL_CONF
					echo "# Variable (re-)added by debconf:" >> $CONTROL_CONF
					echo "$1=" >> $CONTROL_CONF
					echo "" >> $CONTROL_CONF
					}
			fi
			;;
	esac
}





# Substitute in the values from the debconf db.
# See `man debconf-devel`
# Non-default values will be set in default.
# Default values will be set in default if they were set there already,
# otherwise they will be set in blockcontrol.conf

my_db_get BLOCKLIST_FORMAT
case "$RET" in
	'eMule ipfilter.dat format')
		# Set blocklist format
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"d\"|" $FILE_TO_CHANGE
		else
			echo "BLOCKLIST_FORMAT=\"d\"" >> $CONTROL_DEFAULT
		fi
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_DAT"
		# Define lists that are incompatible with this format:
		# The bluetack ipfilters aren't downloadable anymore (Dec. 2008).
		LISTS_X="$LISTS_P2B $LISTS_P2P"
		# Get the selected lists for this blocklist format:
		db_get moblock/blocklists_dat
		;;
	'PeerGuardian .p2b v2 binary format')
		# Set blocklist format
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"n\"|" $FILE_TO_CHANGE
		else
			echo "BLOCKLIST_FORMAT=\"n\"" >> $CONTROL_DEFAULT
		fi
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_P2B"
		# Define lists that are incompatible with this format:
		LISTS_X="$LISTS_DAT $LISTS_P2P"
		# Get the selected lists for this blocklist format - no debconf here, yet:
		RET=""
		;;
	'PeerGuardian .p2p text format')	# Default
		# Set blocklist format
		sed -i -r "s|^[[:space:]]*BLOCKLIST_FORMAT=.*|BLOCKLIST_FORMAT=\"p\"|" $FILE_TO_CHANGE
		# Define available lists for this format:
		LISTS_POSSIBLE="$LISTS_P2P"
		# Define lists that are incompatible with this format:
		LISTS_X="$LISTS_DAT $LISTS_P2B"
		# Get the selected lists for this blocklist format:
		db_get moblock/blocklists_p2p
		;;
esac

# $RET of the previous db_get gives selected lists seperated with (", ").
# If all lists were deselected replace empty value with dummy, otherwise
# LISTS_XGET will stay empty although it should contain all LISTs:
LISTS_GET_NAME_COMMA=${RET:-dummy}
LISTS_GET_NAME="$(echo $LISTS_GET_NAME_COMMA | sed 's/,//g')"

# Add (if necessary) selected blocklists to blocklists.list
for LIST_NAME in $LISTS_GET_NAME ; do
	# Translate human readable/debconf LIST_NAME to LIST_URL.
	LIST_NAME2LIST_URL
	# Add selected lists to blocklists.list
	if [ "$LIST_URL" = dummy ] ; then
		# just ignore the dummy
		true
	elif grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX" $BLOCKLISTS_LIST ; then
		# LIST_URL is already selected.
		# If already selected list is used with the deprecated notimestamp option we're fine, too.
		true
	elif LIST_NAME2LIST_URL_ALT && [ -n "$LIST_URL_ALT" ] && grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT" $BLOCKLISTS_LIST ; then
		# LIST_URL_ALT is already selected with an alternative URL.
		# If already selected list is used with the deprecated notimestamp option
		# we're fine, too
		true
	elif grep -Eq "^#(http://)?$LIST_URL_REGEX$" $BLOCKLISTS_LIST ; then
		# LIST is commented, uncomment it.
		# The REGEX is very strict, so that no user changes get lost.
		# An occurence of http:// is kept on uncommenting.
		sed -i -r "s|^#((http://)?$LIST_URL_REGEX)$|\1|" $BLOCKLISTS_LIST
	else
		# LIST is not in blocklists.list (at least not in the very strict form described before).
		echo >> $BLOCKLISTS_LIST
		echo "# Added by debconf:" >> $BLOCKLISTS_LIST
		echo $LIST_URL >> $BLOCKLISTS_LIST
	fi
done

# Gives selected lists seperated with "|":
LISTS_GET_NAME_PIPE="$(echo $LISTS_GET_NAME | sed "s/\ /\|/g")"
for LIST_NAME in $LISTS_POSSIBLE ; do
	# Gives deselected (known to debconf but not configured to be used) lists seperated with space:
	LISTS_XGET="$LISTS_XGET $(echo $LIST_NAME | grep -Ev $LISTS_GET_NAME_PIPE || true)"
done

# These lists were either deselected or are in an incompatible format:
for LIST_NAME in $LISTS_XGET $LISTS_X ; do
	# Translate human readable/debconf LIST_NAME to LIST_URL.
	LIST_NAME2LIST_URL
	LIST_NAME2LIST_URL_ALT
	# Remove deselected and known incompatible lists from blocklists.list
	if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX" $BLOCKLISTS_LIST ; then
		# LIST_NAME is currently selected, add a # in front of pattern
		sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_REGEX|#&|" $BLOCKLISTS_LIST
	fi
	if [ -n "$LIST_URL_ALT" ] && grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT" $BLOCKLISTS_LIST ; then	# List is currently selected
		# LIST_NAME is currently selected with alternative URL, add a # in front of pattern
		sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL_ALT|#&|" $BLOCKLISTS_LIST
	fi
done

# Unavailable lists:
if [ "$BLOCKLIST_FORMAT" = d ] ; then
	for LIST_URL in www.bluetack.co.uk/config/nipfilter.dat.gz www.bluetack.co.uk/config/pipfilter.dat.gz ; do
		if grep -Eq "^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL" $BLOCKLISTS_LIST ; then
			echo -n "Disabling $LIST_URL because it is no more downloadable directly"
			sed -i -r "s|^[[:space:]]*(notimestamp)?[[:space:]]*(http://)?$LIST_URL|# Disabled because list is no more downloadable directly: &|" $BLOCKLISTS_LIST
			echo "."
		fi
	done
fi

my_db_get LOG_TIMESTAMP
case "$RET" in
	'false')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_TIMESTAMP=.*|LOG_TIMESTAMP=\"0\"|" $FILE_TO_CHANGE
		else
			echo "LOG_TIMESTAMP=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'true')	# Default
		sed -i -r "s|^[[:space:]]*LOG_TIMESTAMP=.*|LOG_TIMESTAMP=\"1\"|" $FILE_TO_CHANGE
		;;
esac

my_db_get LOG_SYSLOG
case "$RET" in
	'false')	# Default
		sed -i -r "s|^[[:space:]]*LOG_SYSLOG=.*|LOG_SYSLOG=\"0\"|" $FILE_TO_CHANGE
		;;
	'true')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_SYSLOG=.*|LOG_SYSLOG=\"1\"|" $FILE_TO_CHANGE
		else
			echo "LOG_SYSLOG=\"1\"" >> "$CONTROL_DEFAULT"
		fi
		;;
esac

my_db_get LOG_IPTABLES
case "$RET" in
	'Do not log blocked packets to syslog.')	# Default
		sed -i -r "s|^[[:space:]]*LOG_IPTABLES=.*|LOG_IPTABLES=\"\"|" $FILE_TO_CHANGE
		;;
	'Log blocked packets to syslog.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*LOG_IPTABLES=.*|LOG_IPTABLES=\"LOG --log-level info\"|" $FILE_TO_CHANGE
		else
			echo "LOG_IPTABLES=\"LOG --log-level info\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get VERBOSITY
case "$RET" in
	'Output to STDOUT is off (only errors will be reported).')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"0\"|" $FILE_TO_CHANGE
		else
			echo "VERBOSITY=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Output to STDOUT is on.')	# Default
		sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"1\"|" $FILE_TO_CHANGE
		;;
	'Output to STDOUT is on but no warning will be shown if an operation is configured not to be executed.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*VERBOSITY=.*|VERBOSITY=\"2\"|" $FILE_TO_CHANGE
		else
			echo "VERBOSITY=\"2\"" >> "$CONTROL_DEFAULT"
		fi
		;;
esac

my_db_get INIT
case "$RET" in
	'false')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*INIT=.*|INIT=\"0\"|" $FILE_TO_CHANGE
		else
			echo "INIT=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'true')	# Default
		sed -i -r "s|^[[:space:]]*INIT=.*|INIT=\"1\"|" $FILE_TO_CHANGE
		;;
esac

my_db_get CRON
case "$RET" in
	'false')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*CRON=.*|CRON=\"0\"|" $FILE_TO_CHANGE
		else
			echo "CRON=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'true')	# Default
		sed -i -r "s|^[[:space:]]*CRON=.*|CRON=\"1\"|" $FILE_TO_CHANGE
		;;
esac

my_db_get NFQUEUE_NUMBER
if [ "$RET" = 92 ] ; then	# Default
	sed -i -r "s|^[[:space:]]*NFQUEUE_NUMBER=.*|NFQUEUE_NUMBER=\"$RET\"|" $FILE_TO_CHANGE
else
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*NFQUEUE_NUMBER=.*|NFQUEUE_NUMBER=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "NFQUEUE_NUMBER=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
fi

my_db_get IPTABLES_SETTINGS
case "$RET" in
	'Do not set any iptables rules. You or another script/firewall has to do this!')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"0\"|" $FILE_TO_CHANGE
		else
			echo "IPTABLES_SETTINGS=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Use separate iptables chains for MoBlock.')	# Default
		sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"1\"|" $FILE_TO_CHANGE
		;;
	'Only set custom iptables rules.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_SETTINGS=.*|IPTABLES_SETTINGS=\"2\"|" $FILE_TO_CHANGE
		else
			echo "IPTABLES_SETTINGS=\"2\"" >> "$CONTROL_DEFAULT"
		fi
		;;
esac

my_db_get IPTABLES_ACTIVATION
case "$RET" in
	'Do nothing. You or another script/firewall has to do this!')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"0\"|" $FILE_TO_CHANGE
		else
			echo "IPTABLES_ACTIVATION=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Send all NEW traffic to the iptables chains of MoBlock.')	# Default
		sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"1\"|" $FILE_TO_CHANGE
		;;
	'Send all traffic to the iptables chains of MoBlock.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*IPTABLES_ACTIVATION=.*|IPTABLES_ACTIVATION=\"2\"|" $FILE_TO_CHANGE
		else
			echo "IPTABLES_ACTIVATION=\"2\"" >> "$CONTROL_DEFAULT"
		fi
		;;
esac

my_db_get REJECT
case "$RET" in
	'false')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT=.*|REJECT=\"0\"|" $FILE_TO_CHANGE
		else
			echo "REJECT=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'true')	# Default
		sed -i -r "s|^[[:space:]]*REJECT=.*|REJECT=\"1\"|" $FILE_TO_CHANGE
		;;
esac

my_db_get REJECT_IN
case "$RET" in
	'DROP')	# Default
		sed -i -r "s|^[[:space:]]*REJECT_IN=.*|REJECT_IN=\"$RET\"|" $FILE_TO_CHANGE
		;;
	'REJECT')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_IN=.*|REJECT_IN=\"$RET\"|" $FILE_TO_CHANGE
		else
			echo "REJECT_IN=\"$RET\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get REJECT_OUT
case "$RET" in
	'DROP')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_OUT=.*|REJECT_OUT=\"$RET\"|" $FILE_TO_CHANGE
		else
			echo "REJECT_OUT=\"$RET\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'REJECT')	# Default
		sed -i -r "s|^[[:space:]]*REJECT_OUT=.*|REJECT_OUT=\"$RET\"|" $FILE_TO_CHANGE
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get REJECT_FW
case "$RET" in
	'DROP')	# Default
		sed -i -r "s|^[[:space:]]*REJECT_FW=.*|REJECT_FW=\"$RET\"|" $FILE_TO_CHANGE
		;;
	'REJECT')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*REJECT_FW=.*|REJECT_FW=\"$RET\"|" $FILE_TO_CHANGE
		else
			echo "REJECT_FW=\"$RET\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Do not touch my settings. Use the current custom value instead.')
		true
		;;
esac

my_db_get ACCEPT
case "$RET" in
	'false')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*ACCEPT=.*|ACCEPT=\"0\"|" $FILE_TO_CHANGE
		else
			echo "ACCEPT=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'true')	# Default
		sed -i -r "s|^[[:space:]]*ACCEPT=.*|ACCEPT=\"1\"|" $FILE_TO_CHANGE
		;;
esac

my_db_get WHITE_TCP_OUT
if [ "$RET" = "80 443" ] ; then
	# Default, but change port numbers to associated service names because of mobloquer (0.5) bug.
	# blockcontrol.conf now ships with "http https"
	sed -i -r "s|^[[:space:]]*WHITE_TCP_OUT=.*|WHITE_TCP_OUT=\"http https\"|" $FILE_TO_CHANGE
elif [ "$RET" = "http https" ] ; then	# Default
	sed -i -r "s|^[[:space:]]*WHITE_TCP_OUT=.*|WHITE_TCP_OUT=\"$RET\"|" $FILE_TO_CHANGE
else
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		# change port numbers to associated service name because of mobloquer (0.5) bug.
		RET_FIXED="$(echo $RET | sed "s|^80 443|http https|")"
		sed -i -r "s|^[[:space:]]*WHITE_TCP_OUT=.*|WHITE_TCP_OUT=\"$RET_FIXED\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_TCP_OUT=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
fi

my_db_get WHITE_UDP_OUT
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_OUT=.*|WHITE_UDP_OUT=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_UDP_OUT=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*WHITE_UDP_OUT=.*|WHITE_UDP_OUT=\"$RET\"|" $FILE_TO_CHANGE
fi

my_db_get WHITE_TCP_IN
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_IN=.*|WHITE_TCP_IN=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_TCP_IN=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*WHITE_TCP_IN=.*|WHITE_TCP_IN=\"$RET\"|" $FILE_TO_CHANGE
fi

my_db_get WHITE_UDP_IN
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_IN=.*|WHITE_UDP_IN=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_UDP_IN=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*WHITE_UDP_IN=.*|WHITE_UDP_IN=\"$RET\"|" $FILE_TO_CHANGE
fi

my_db_get WHITE_TCP_FORWARD
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_TCP_FORWARD=.*|WHITE_TCP_FORWARD=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_TCP_FORWARD=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*WHITE_TCP_FORWARD=.*|WHITE_TCP_FORWARD=\"$RET\"|" $FILE_TO_CHANGE
fi

my_db_get WHITE_UDP_FORWARD
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*WHITE_UDP_FORWARD=.*|WHITE_UDP_FORWARD=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "WHITE_UDP_FORWARD=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*WHITE_UDP_FORWARD=.*|WHITE_UDP_FORWARD=\"$RET\"|" $FILE_TO_CHANGE
fi

my_db_get WHITE_LOCAL
case "$RET" in
	'Do nothing.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"0\"|" $FILE_TO_CHANGE
		else
			echo "WHITE_LOCAL=\"0\"" >> "$CONTROL_DEFAULT"
		fi
		;;
	'Automatically whitelist LAN traffic and traffic on the loopback device.')	# Default
		sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"1\"|" $FILE_TO_CHANGE
		;;
	'Whitelist the loopback device.')
		if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
			sed -i -r "s|^[[:space:]]*WHITE_LOCAL=.*|WHITE_LOCAL=\"2\"|" $FILE_TO_CHANGE
		else
			echo "WHITE_LOCAL=\"2\"" >> "$CONTROL_DEFAULT"
		fi
		;;
esac

my_db_get IP_REMOVE
if [ -n "$RET" ] ; then
	if [ "$FILE_TO_CHANGE" = "$CONTROL_DEFAULT" ] ; then
		sed -i -r "s|^[[:space:]]*IP_REMOVE=.*|IP_REMOVE=\"$RET\"|" $FILE_TO_CHANGE
	else
		echo "IP_REMOVE=\"$RET\"" >> "$CONTROL_DEFAULT"
	fi
else	# Default
		sed -i -r "s|^[[:space:]]*IP_REMOVE=.*|IP_REMOVE=\"$RET\"|" $FILE_TO_CHANGE
fi

# Load configuration. This overwrites the above values.
if [ -f "$CONTROL_CONF" ] ; then
	. $CONTROL_CONF || { echo "Error: Failed to source $CONTROL_CONF although this file exists."; exit 1; }
fi

# Load default configuration. This overwrites the above values
if [ -f "$CONTROL_DEFAULT" ] ; then
	. $CONTROL_DEFAULT || { echo "Error: Failed to source $CONTROL_DEFAULT although this file exists."; exit 1; }
fi

# Add a line to the allow list.
# The configuration files must have been sourced already for this!
db_get moblock/allowlist
[ -z "$RET" ] || {
	[ -f "$ALLOW_OUT" ] || touch "$ALLOW_OUT"
	echo "" >> "$ALLOW_OUT"	# add newline first in case the current file lacks one!
	echo $RET >> "$ALLOW_OUT"
	if [ -n "$ALLOW_IN" ] && [ "$ALLOW_IN" != "$ALLOW_OUT" ] ; then
		[ -f "$ALLOW_IN" ] || touch "$ALLOW_IN"
		echo "" >> "$ALLOW_IN"	# add newline first in case the current file lacks one!
		echo $RET >> "$ALLOW_IN"
	fi
	if [ -n "$ALLOW_FW" ] && [ "$ALLOW_FW" != "$ALLOW_OUT" ] ; then
		[ -f "$ALLOW_FW" ] || touch "$ALLOW_FW"
		echo "" >> "$ALLOW_FW"	# add newline first in case the current file lacks one!
		echo $RET >> "$ALLOW_FW"
	fi
}

# done with debconf...
db_stop

# End of substitute in the values from the debconf db.





# Test correct BLOCKLIST_FORMAT setting.
# Set the blocklist name depending on the type of the blocklist (configuration setting).
test_set_BLOCKLIST

# For updates from versions prior to blockcontrol 1.2 (change of the blocklist file places):
if [ -n "$2" ] && dpkg --compare-versions "$2" lt "1.2" ; then

	#
	# Move old master blocklists to new places.
	#
	if [ "$MASTER_BLOCKLIST_DIR" = /var/lib/moblock ] && [ -d /var/lib/moblock ] ; then
		LISTS="guarding.p2p guarding.p2p.backup guarding.p2b guarding.p2b.backup ipfilter.dat ipfilter.dat.backup"
		for LIST in $LISTS ; do
			[ -f /etc/blockcontrol/$LIST ] && [ ! -f /var/lib/moblock/$LIST ] && {
				echo -n "Moving /etc/blockcontrol/$LIST to /var/lib/moblock/"
				mv /etc/blockcontrol/$LIST /var/lib/moblock/ && echo "."
				}
		done
	fi

	#
	# Move old downloaded lists to new places.
	#
	for LIST_NAME in $LISTS_P2P ; do
		LIST_NAME2LIST_URL_ALT
		LIST_NAME_FIX="$(echo $LIST_NAME | sed "s|.*://|_|" | sed "s|/|_|g" | sed "s/?/_/g" | sed "s/ /_/g")"
		FILE_NAME="$(basename $LIST_URL_ALT)"
		# Set blocklist directory name.
		BLOCKLIST_DIR="$BLOCKLISTS_DIR/$LIST_NAME_FIX"
		[ -f "$BLOCKLISTS_DIR/used/$FILE_NAME" ] && {
			echo -n "Moving $LIST_NAME ..."
			[ -f "$BLOCKLISTS_DIR/$FILE_NAME" ] && rm "$BLOCKLISTS_DIR/$FILE_NAME"
			# Gives the name of successfully downloaded file.
			BLOCKLIST_DOWNLOADED="$BLOCKLIST_DIR/downloaded/$LIST_NAME_FIX"
			# BLOCKLIST_DOWNLOADED is extracted to this file.
			BLOCKLIST_EXTRACTED="$BLOCKLIST_DIR/extracted/$LIST_NAME_FIX"
			[ -d "$BLOCKLISTS_DIR" ] || mkdir "$BLOCKLISTS_DIR" || { log_failure_msg "Error: mkdir exited with $?" ; exit 1 ; }
			[ -d "$BLOCKLIST_DIR" ] || mkdir "$BLOCKLIST_DIR" || { log_failure_msg "Error: mkdir exited with $?" ; exit 1 ; }
			[ -d "$BLOCKLIST_DIR/download" ] || mkdir "$BLOCKLIST_DIR/download" || { log_failure_msg "Error: mkdir exited with $?" ; exit 1 ; }
			[ -d "$(dirname $BLOCKLIST_DOWNLOADED)" ] || mkdir "$(dirname $BLOCKLIST_DOWNLOADED)" || { log_failure_msg "Error: mkdir exited with $?" ; exit 1 ; }
			[ -e "$BLOCKLIST_DIR/download/$FILE_NAME" ] || cp "$BLOCKLISTS_DIR/used/$FILE_NAME" "$BLOCKLIST_DIR/download/" || { log_failure_msg "Error: cp exited with $?" ; exit 1 ; }
			[ -e "$BLOCKLIST_DOWNLOADED" ] || mv "$BLOCKLISTS_DIR/used/$FILE_NAME" "$BLOCKLIST_DOWNLOADED" || { log_failure_msg "Error: cp exited with $?" ; exit 1 ; }
			echo "Done."

			# Unpack the lists
			echo -n "Extracting $LIST_NAME ..."
			# Create necessary directories if missing:
			[ -d "$(dirname $BLOCKLIST_EXTRACTED)" ] || mkdir "$(dirname $BLOCKLIST_EXTRACTED)" || { log_failure_msg " Error: mkdir exited with $?" ; exit 1 ; }

			# Read the first six (length of the 7z header) bytes of the packed
			# blocklist:
			case "$(head -c 6 $BLOCKLIST_DOWNLOADED)" in
				# 7z packed file
				"$(/usr/bin/printf '\x37\x7A\xBC\xAF\x27\x1C')")
					echo -n ", detected 7z"
					# TODO: 7z, 7zr, ...
					test_external p7zip || exit $E_XEXTERNAL
					p7zip -d < "$BLOCKLIST_DOWNLOADED" > "$BLOCKLIST_EXTRACTED.tmp" || {
						log_failure_msg " Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
						log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
						log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
						rm "$BLOCKLIST_DOWNLOADED" || { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
						exit $E_BLOCKLIST
					}
					mv -f "$BLOCKLIST_EXTRACTED.tmp" "$BLOCKLIST_EXTRACTED" || { log_failure_msg "Error: mv exited with $?" ; exit 1 ; }
					echo "... done."
					;;
				# gz packed file
				"$(/usr/bin/printf '\x1F\x8B\x08')"*)
					echo -n ", detected gz"
					zcat "$BLOCKLIST_DOWNLOADED" > "$BLOCKLIST_EXTRACTED.tmp" || {
						log_failure_msg " Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
						log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
						log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
						rm "$BLOCKLIST_DOWNLOADED" || { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
						exit $E_BLOCKLIST
					}
					mv -f "$BLOCKLIST_EXTRACTED.tmp" "$BLOCKLIST_EXTRACTED" || { log_failure_msg "Error: mv exited with $?" ; exit 1 ; }
					echo "... done."
					;;
				# zip packed file
				"$(/usr/bin/printf '\x50\x4B\x03\x04')"*)
					echo -n ", detected zip"
					test_external unzip || exit $E_XEXTERNAL
					unzip -p "$BLOCKLIST_DOWNLOADED" > "$BLOCKLIST_EXTRACTED.tmp" || {
						log_failure_msg " Error $E_BLOCKLIST: Failed to extract $LIST_NAME."
						log_failure_msg "Removing $BLOCKLIST_DOWNLOADED."
						log_failure_msg "Check your configuration in $BLOCKLISTS_LIST and try a new \"$(basename $0) update\"."
						rm "$BLOCKLIST_DOWNLOADED" || { log_failure_msg "Error: rm exited with $?" ; exit 1 ; }
						exit $E_BLOCKLIST
					}
					mv -f $BLOCKLIST_EXTRACTED.tmp $BLOCKLIST_EXTRACTED || { log_failure_msg "Error: mv exited with $?" ; exit 1 ; }
					echo "... done."
					;;
				# Assuming non-packed otherwise:
				*)
					echo -n ", not packed"
					ln -fs $BLOCKLIST_DOWNLOADED $BLOCKLIST_EXTRACTED || { log_failure_msg " Error: ln exited with $?"; exit 1; }
					echo "... done."
					;;
			esac
		}
	done

	# Remove obsolete directory if it is empty:
	[ -d "$BLOCKLISTS_DIR/used" ] && rmdir "$BLOCKLISTS_DIR/used" 2>/dev/null || true

	# Remove the old -nfq and -ipq "configuration" files
	if [ -f /etc/init.d/moblock-ipq ] ; then
		echo -n "Removing old /etc/init.d/moblock-ipq and links"
		rm /etc/init.d/moblock-ipq
		update-rc.d moblock-ipq remove
		echo "."
	fi
	if [ -f /etc/init.d/moblock-nfq ] ; then
		echo -n "Removing old /etc/init.d/moblock-nfq and links"
		rm /etc/init.d/moblock-nfq
		update-rc.d moblock-nfq remove
		echo "."
	fi
	if [ -f /etc/cron.daily/moblock-ipq ] ; then
		echo -n "Removing old /etc/cron.daily/moblock-ipq"
		rm /etc/cron.daily/moblock-ipq
		echo "."
	fi
	if [ -f /etc/cron.daily/moblock-nfq ] ; then
		echo -n "Removing old /etc/cron.daily/moblock-nfq"
		rm /etc/cron.daily/moblock-nfq
		echo "."
	fi
	if [ -f /etc/logrotate.d/moblock-ipq ] ; then
		echo -n "Removing old /etc/logrotate.d/moblock-ipq"
		rm /etc/logrotate.d/moblock-ipq
		echo "."
	fi
	if [ -f /etc/logrotate.d/moblock-nfq ] ; then
		echo -n "Removing old /etc/logrotate.d/moblock-nfq"
		rm /etc/logrotate.d/moblock-nfq
		echo "."
	fi
fi

if [ "$INIT" -ne 0 ] && [ -x "/etc/init.d/moblock" ] ; then
	# dh_installdeb inserts code to execute init "start".
	echo "Starting $DESC. If any blocklist is missing, it will be downloaded now. This"
	echo "may take several minutes. Please be patient and don't abort. If you want to"
	echo "follow the process, then do in another terminal a"
	echo " tail -f /var/log/blockcontrol.log"
	echo "The lists are saved to $BLOCKLISTS_DIR/."
	echo "If starting $DESC fails, then your installation will fail, too. To turn the"
	echo "automatic starting of $DESC off, set in $CONTROL_DEFAULT:"
	echo " INIT=\"0\""
fi

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

exit 0
